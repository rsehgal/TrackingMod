#include "MyDetectorConstruction.h"
#include "G4RunManager.hh"
#include "G4NistManager.hh"
#include "G4Box.hh"
#include <G4Tubs.hh>
#include "G4Cons.hh"
#include "G4Orb.hh"
#include "G4Sphere.hh"
#include "G4Trd.hh"
#include "G4LogicalVolume.hh"
#include "G4PVPlacement.hh"
#include "G4SystemOfUnits.hh"
#include "G4VPhysicalVolume.hh"
#include "G4Isotope.hh"
#include "G4Element.hh"
#include "G4Material.hh"
#include "G4UnitsTable.hh"
#include <cmath>
#include <iostream>


int MyDetectorConstruction::stripNum = 0;
int MyDetectorConstruction::blockNum=-1;
int MyDetectorConstruction::eBlockNum=1;


MyDetectorConstruction::MyDetectorConstruction(){

}

MyDetectorConstruction::~MyDetectorConstruction(){}

G4VPhysicalVolume* MyDetectorConstruction::Construct(){
  
  G4NistManager* nist = G4NistManager::Instance();
  G4bool checkOverlaps = true;

  
  // Envelope params
  //
  G4double env_sizeXY = 20*m, env_sizeZ = 30*m;
  //G4Material* env_mat = nist->FindOrBuildMaterial("G4_WATER");
  
  //     
  // World
  //
  G4double world_sizeXYZ = 200*cm;
  G4double world_sizeXY = 1.2*env_sizeXY;
  G4double world_sizeZ  = 1.2*env_sizeZ;
  
 G4Material* world_mat = nist->FindOrBuildMaterial("G4_Galactic");

  G4Box* solidWorld =    
    new G4Box("World",                       //its name
       0.8*world_sizeXYZ, 0.8*world_sizeXYZ, 0.8*world_sizeXYZ);     //its size

     
  G4LogicalVolume* logicWorld =                         
    new G4LogicalVolume(solidWorld,          //its solid
                        world_mat,           //its material
                        "World");            //its name




                                   
  G4VPhysicalVolume* physWorld = 
    new G4PVPlacement(0,                     //no rotation
                      G4ThreeVector(),       //at (0,0,0)
                      logicWorld,            //its logical volume
                      "World",               //its name
                      0,                     //its mother  volume
                      false,                 //no boolean operation
                      0,                     //copy number
                      checkOverlaps);        //overlaps checking


 G4Material *Si=nist->FindOrBuildMaterial("G4_AIR");
//  G4LogicalVolume *planeLogical = GetBlock("planeDeltaE",2.5*cm,2.5*cm,0.0025*cm,Si,16,0.0025*cm,1);

  G4LogicalVolume *planeE1Logical = GetBlock("planeE1",50*cm,50*cm,0.5*cm,Si,32,0.5*cm,1);
  G4LogicalVolume *planeE2Logical = GetBlock("planeE2",50*cm,50*cm,0.5*cm,Si,32,0.5*cm,2);
  G4LogicalVolume *planeE = CreateEBlock(planeE1Logical, planeE2Logical, 1.*cm, Si);

for(int k=0; k < 8 ; k++){
if(k==0 || k==3 || k==4 || k==7)
	continue;
 eBlockNum++;
 G4VPhysicalVolume *planeEPhy = new G4PVPlacement(0,
                            G4ThreeVector(0.,0.,(-105+30*k)*cm),
                            planeE,
                            "Module"+std::to_string(eBlockNum),
                            logicWorld,
                            false,
			    eBlockNum,
                           checkOverlaps);
}

G4Material *Pb=nist->FindOrBuildMaterial("G4_U");
//Trying to create scattering of collection of bricks of dimension 10cm X 5cm X 3cm
G4LogicalVolume *brickLane = GetBlock("brickLane",15*cm,2.5*cm,1.5*cm,Pb,3,1.5*cm,1);
G4LogicalVolume *brickLanePlane = GetBlock("brickLanePlane",15*cm,15*cm,1.5*cm,Pb,brickLane,6,2);
G4LogicalVolume *brickLanePlaneBlock = GetBlock("brickLanePlaneBlock",15*cm,15*cm,15*cm,Pb,brickLanePlane,10,3);
G4VPhysicalVolume *brickLanePhy = new G4PVPlacement(0,
                            G4ThreeVector(0.,0.,0.),
                            brickLanePlaneBlock,
                            //"Module"+std::to_string(eBlockNum),
							"LanePlaneBlock1",
                            logicWorld,
                            false,
							//eBlockNum,
							0,
                           checkOverlaps);

	return physWorld;
}
/*
** Helper functions for Geometry creation will be taken from DetectorHelpers
*/
